---
import { getGames, getPlayByPlay } from '@lib/gamera'
import Layout from './layout.astro'
import {
  type InningAtBatEvent,
  type InningPlayByPlay,
  type MlbGameDataResponse,
  type GameraPlayerReference,
  filterScoringPlays,
} from '@statmuse/core/gamera'
import { find, orderBy } from 'lodash-es'
import GameInfo from './game-info.astro'
import Matchup from './matchup.svelte'
import PitchByPitch from './pitch-by-pitch.svelte'
import Linescore from './linescore.svelte'
import PlayByPlay from './play-by-play.svelte'
import LivegameHero from './livegame-hero.astro'

interface Props {
  gameData: MlbGameDataResponse
  gameId: string
}

const { gameData, gameId } = Astro.props

const {
  networkName,
  awayTeam: awayTeamModel,
  homeTeam: homeTeamModel,
  teams,
  venue,
  weather,
  officials,
  players,
} = gameData

const [homeScores, awayScores, playByPlay] = await Promise.all([
  getGames({ context: Astro, domain: 'mlb', teamId: homeTeamModel.teamId }),
  getGames({ context: Astro, domain: 'mlb', teamId: awayTeamModel.teamId }),
  getPlayByPlay({ context: Astro, gameId }),
])

const innings = playByPlay?.innings

const getLatestCount = (innings: InningPlayByPlay[]) => {
  const latestInning = innings[innings.length - 1]

  const bottomHalf = latestInning.halves[1]
  const topHalf = latestInning.halves[0]

  let atBatEvents: InningAtBatEvent[] = []

  let half

  if (bottomHalf.events.filter((p) => p.type === 'atBat').length > 0) {
    atBatEvents = bottomHalf.events.filter((p) => p.type === 'atBat')
    half = bottomHalf.half
  } else if (topHalf.events.filter((p) => p.type === 'atBat').length > 0) {
    atBatEvents = topHalf.events.filter((p) => p.type === 'atBat')
    half = topHalf.half
  }

  const lastAtBatEvent = atBatEvents[atBatEvents.length - 1]

  const pitchOrStealEvents = lastAtBatEvent.events.filter(
    (e) => e.type === 'pitch' || e.type === 'steal',
  )

  const lastPitchOrCaughtStealing =
    pitchOrStealEvents[pitchOrStealEvents.length - 1]

  if (!lastPitchOrCaughtStealing) return { half, inning: latestInning.number }

  return {
    half:
      half === 'top' && lastPitchOrCaughtStealing.count.outs === 3
        ? ('mid' as const)
        : half === 'bottom' && lastPitchOrCaughtStealing.count.outs === 3
        ? ('end' as const)
        : half,
    inning: latestInning.number,
    ...lastPitchOrCaughtStealing.count,
  }
}

const getCurrentMatchup = (innings: InningPlayByPlay[]) => {
  const latestInning = innings[innings.length - 1]

  const bottomHalf = latestInning.halves[1]
  const topHalf = latestInning.halves[0]

  let atBatEvents: InningAtBatEvent[] = []

  let half

  if (bottomHalf.events.filter((p) => p.type === 'atBat').length > 0) {
    atBatEvents = bottomHalf.events.filter((p) => p.type === 'atBat')
    half = bottomHalf.half
  } else if (topHalf.events.filter((p) => p.type === 'atBat').length > 0) {
    atBatEvents = topHalf.events.filter((p) => p.type === 'atBat')
    half = topHalf.half
  }

  const lastAtBatEvent = atBatEvents[atBatEvents.length - 1]

  return {
    half,
    ...lastAtBatEvent,
  }
}

type MatchUp = ReturnType<typeof getCurrentMatchup>

const currentMatchUp = playByPlay
  ? getCurrentMatchup(playByPlay.innings)
  : undefined
const latestCount = playByPlay ? getLatestCount(playByPlay.innings) : undefined

const getPlayerMatchup = (
  matchupInfo: MatchUp | undefined,
  team: 'away' | 'home',
) => {
  const playerInfo =
    team === 'away' && matchupInfo?.half === 'top'
      ? matchupInfo?.batter
      : team === 'home' && matchupInfo?.half === 'top'
      ? matchupInfo?.pitcher
      : team === 'away' && matchupInfo?.half === 'bottom'
      ? matchupInfo?.pitcher
      : matchupInfo?.batter

  const player = find(players, { id: playerInfo?.playerId })

  const teamModel = team === 'away' ? awayTeamModel : homeTeamModel

  const positions = find(teamModel.players, { playerId: player?.id })?.lineup
    .positions

  return {
    ...player,
    handedness: playerInfo?.handedness,
    positions,
  }
}

const awayTeam = find(teams, { teamId: awayTeamModel.teamId })
const homeTeam = find(teams, { teamId: homeTeamModel.teamId })

const playerMap = players?.reduce(
  (acc, p) => ({ ...acc, [p.id]: p }),
  {} as Record<number, GameraPlayerReference>,
)

const scoringInnings = filterScoringPlays(innings ?? [])
---

<Layout {awayTeam} {homeTeam}>
  <LivegameHero
    slot="hero"
    network={networkName}
    awayScore={awayTeamModel.score}
    homeScore={homeTeamModel.score}
    {latestCount}
    {awayTeam}
    awayScores={awayScores && {
      ...awayScores,
      games: orderBy(awayScores.games, 'gameDate', 'desc'),
    }}
    {homeTeam}
    homeScores={homeScores && {
      ...homeScores,
      games: orderBy(homeScores.games, 'gameDate', 'desc'),
    }}
  />
  <Fragment slot="game">
    <Matchup
      client:load
      {awayTeam}
      {homeTeam}
      awayPlayer={getPlayerMatchup(currentMatchUp, 'away')}
      homePlayer={getPlayerMatchup(currentMatchUp, 'home')}
      {...latestCount}
    />
    <PitchByPitch client:load />
    <Linescore
      client:load
      {awayTeam}
      {homeTeam}
      {awayTeamModel}
      {homeTeamModel}
    />
    <Fragment>
      {
        scoringInnings?.map((inning) => {
          const number = inning.number
          const [topHalf, bottomHalf] = inning.halves
          return (
            <Fragment>
              {topHalf.events.length > 0 && (
                <PlayByPlay
                  inningTitle={`Top ${number}`}
                  inning={topHalf}
                  {playerMap}
                  colors={awayTeam?.colors}
                />
              )}
              {bottomHalf.events.length > 0 && (
                <PlayByPlay
                  inningTitle={`Bottom ${number}`}
                  inning={bottomHalf}
                  {playerMap}
                  colors={homeTeam?.colors}
                />
              )}
            </Fragment>
          )
        })
      }
    </Fragment>
    <GameInfo {venue} {weather} {officials} />
  </Fragment>
  <Fragment slot="plays">
    {
      innings?.map((inning) => {
        const number = inning.number
        const [topHalf, bottomHalf] = inning.halves

        return (
          <Fragment>
            <PlayByPlay
              inningTitle={`Top ${number}`}
              inning={topHalf}
              {playerMap}
            />
            <PlayByPlay
              inningTitle={`Bottom ${number}`}
              inning={bottomHalf}
              {playerMap}
            />
          </Fragment>
        )
      })
    }
  </Fragment>
</Layout>
